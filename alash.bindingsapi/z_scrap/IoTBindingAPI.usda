#usda 1.0
(
    """ 
    IoTBindingAPI Schema
    
    This schema defines an API for binding USD attributes to external IoT data sources
    like MQTT, REST APIs, databases, etc. It provides a standardized way to connect
    USD scene graph data to real-world sensor data and control systems.
    """
    subLayers = [
        @usd/schema.usda@
    ]
)

class "IoTBindingAPI" (
    inherits = </APISchemaBase>
    doc = """IoTBindingAPI provides attributes for binding USD properties to external IoT data sources.
    
    This API schema can be applied to any prim to enable its attributes to be bound to
    external data sources like MQTT brokers, REST APIs, databases, or other IoT systems.
    
    Example usage:
    ```
    def Cube "Sensor" (
        prepend apiSchemas = ["IoTBindingAPI"]
    )
    {
        double temperature = 22.0 (
            customData = {
                dictionary binding = {
                    string protocol = "mqtt"
                    string operation = "stream" 
                    string uri = "mqtt://localhost:1883"
                    string topic = "sensors/temperature"
                    string jsonPath = "$.value"
                    int refreshInterval = 1000
                }
            }
        )
    }
    ```
    """
    customData = {
        string className = "IoTBindingAPI"
        string libraryName = "iotBinding"
        dictionary schemaKind = {
            string value = "nonAppliedAPI"
        }
    }
)
{
    # Binding configuration stored in customData dictionary
    uniform dictionary binding:config = {} (
        doc = """Root binding configuration dictionary.
        
        Contains all binding-related configuration for this attribute.
        This is the primary way to configure IoT bindings."""
    )
    
    # Protocol-specific configurations
    uniform string binding:protocol = "" (
        allowedTokens = ["mqtt", "rest", "sql", "grpc", "websocket", "file", "modbus", "opcua"]
        doc = """Protocol used for data binding.
        
        Supported protocols:
        - mqtt: MQTT message broker
        - rest: HTTP REST API
        - sql: SQL database query
        - grpc: gRPC service call
        - websocket: WebSocket connection
        - file: File system monitoring
        - modbus: Modbus TCP/RTU protocol
        - opcua: OPC UA industrial protocol"""
    )
    
    uniform string binding:operation = "" (
        allowedTokens = ["read", "write", "stream", "subscribe", "poll"]
        doc = """Operation mode for the binding.
        
        - read: One-time read operation
        - write: One-time write operation  
        - stream: Continuous streaming of data
        - subscribe: Event-based subscription
        - poll: Periodic polling"""
    )
    
    # Connection details
    uniform string binding:uri = "" (
        doc = """Connection URI for the data source.
        
        Examples:
        - mqtt://broker.example.com:1883
        - https://api.example.com/v1
        - postgresql://user:pass@host:5432/db
        - file:///path/to/data.json"""
    )
    
    uniform string binding:topic = "" (
        doc = """Topic, endpoint, or identifier for the specific data.
        
        Protocol-specific examples:
        - MQTT: sensors/temperature/room1
        - REST: /devices/sensor123/temperature
        - SQL: SELECT value FROM sensors WHERE id='temp1'"""
    )
    
    # Data extraction and transformation
    uniform string binding:jsonPath = "" (
        doc = """JSONPath expression for extracting data from response.
        
        Examples:
        - $.data.temperature
        - $.sensors[0].value
        - $.measurements.humidity"""
    )
    
    uniform string binding:xpath = "" (
        doc = """XPath expression for extracting data from XML responses."""
    )
    
    uniform string binding:transform = "" (
        doc = """Data transformation expression or function name.
        
        Can be used to convert units, apply scaling, or other transformations."""
    )
    
    # Timing and refresh behavior
    uniform int binding:refreshInterval = 5000 (
        doc = """Refresh interval in milliseconds for polling operations.
        
        Only applicable for polling-based protocols. Default: 5000ms (5 seconds)"""
    )
    
    uniform string binding:refreshPolicy = "interval" (
        allowedTokens = ["interval", "onchange", "manual", "oncreate"]
        doc = """When to refresh the binding.
        
        - interval: Refresh at regular intervals
        - onchange: Refresh when source data changes
        - manual: Only refresh when explicitly triggered
        - oncreate: Refresh once when binding is created"""
    )
    
    # Authentication and security
    uniform string binding:authMethod = "none" (
        allowedTokens = ["none", "basic", "bearer", "apikey", "oauth2", "mtls", "cert"]
        doc = """Authentication method for the connection."""
    )
    
    uniform string binding:authProfile = "" (
        doc = """Named authentication profile for credentials.
        
        References a credential profile defined externally (not stored in USD)."""
    )
    
    uniform string binding:authScope = "" (
        doc = """Authentication scope or resource identifier for OAuth2/similar."""
    )
    
    # HTTP-specific options
    uniform string binding:httpMethod = "GET" (
        allowedTokens = ["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD"]
        doc = """HTTP method for REST API calls."""
    )
    
    uniform dictionary binding:httpHeaders = {} (
        doc = """Custom HTTP headers for REST API calls."""
    )
    
    # Quality of Service and reliability
    uniform int binding:qos = 0 (
        doc = """Quality of Service level (protocol-specific).
        
        For MQTT: 0 (at most once), 1 (at least once), 2 (exactly once)"""
    )
    
    uniform bool binding:retain = false (
        doc = """Whether to retain messages (MQTT-specific)."""
    )
    
    uniform int binding:timeout = 30000 (
        doc = """Connection timeout in milliseconds. Default: 30 seconds"""
    )
    
    uniform int binding:retryCount = 3 (
        doc = """Number of retry attempts on connection failure."""
    )
    
    # Validation and constraints
    uniform double binding:minValue = -inf (
        doc = """Minimum valid value for numeric data."""
    )
    
    uniform double binding:maxValue = inf (
        doc = """Maximum valid value for numeric data."""
    )
    
    uniform string binding:unit = "" (
        doc = """Unit of measurement for the data (e.g., 'celsius', 'meters', 'percent')."""
    )
    
    # Status and metadata
    uniform bool binding:enabled = true (
        doc = """Whether this binding is currently enabled."""
    )
    
    uniform string binding:description = "" (
        doc = """Human-readable description of this binding."""
    )
    
    uniform dictionary binding:metadata = {} (
        doc = """Additional metadata for the binding."""
    )
}
